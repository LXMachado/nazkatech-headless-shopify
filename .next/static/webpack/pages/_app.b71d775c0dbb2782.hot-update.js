"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/lib/shopify.ts":
/*!****************************!*\
  !*** ./src/lib/shopify.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCheckout: () => (/* binding */ createCheckout),\n/* harmony export */   getAllProducts: () => (/* binding */ getAllProducts),\n/* harmony export */   getProductByHandle: () => (/* binding */ getProductByHandle)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n// Trim any spaces from the domain to prevent URL parsing errors\nconst domain = (\"test-lxm-store.myshopify.com \" || 0).trim();\nconst storefrontAccessToken = \"0ce4d842935ad80150c5f601331ba9f9-1743945461\" || 0;\nconst storePassword = process.env.SHOPIFY_STORE_PASSWORD || '';\nconst apiKey = process.env.SHOPIFY_API_KEY || '';\nconst apiSecret = process.env.SHOPIFY_API_SECRET || '';\n// For debugging\nconsole.log('Environment check:');\nconsole.log('Domain configured:', domain || 'Not set');\nconsole.log('Access token available:', storefrontAccessToken ? 'Yes' : 'No');\nconsole.log('API key available:', apiKey ? 'Yes' : 'No');\nconsole.log('API secret available:', apiSecret ? 'Yes' : 'No');\nconsole.log('Store password available:', storePassword ? 'Yes' : 'No');\n// Try multiple auth strategies\nconst shopifyFetch = async (param)=>{\n    let { query, variables } = param;\n    try {\n        // Set up the API URL - try using the Storefront API specifically\n        const apiUrl = \"https://\".concat(domain, \"/api/2024-01/graphql.json\");\n        // For admin API access we would use:\n        // const apiUrl = `https://${domain}/admin/api/2024-01/graphql.json`;\n        // Prepare headers with authentication - we'll try multiple approaches\n        const headers = {\n            'Content-Type': 'application/json',\n            'X-Shopify-Storefront-Access-Token': storefrontAccessToken\n        };\n        // Try a combination of authentication approaches\n        // Option 1: Use the Storefront API token for public apps\n        // This is already set in the headers above\n        // Option 2: For private apps or admin API\n        if (apiKey && apiSecret) {\n            console.log('Using private app authentication');\n            // For private app authentication, we use the API key as the username\n            // and the password as the API secret/private app password\n            const base64PrivateAppCredentials = Buffer.from(\"\".concat(apiKey, \":\").concat(apiSecret)).toString('base64');\n            headers['Authorization'] = \"Basic \".concat(base64PrivateAppCredentials);\n            // Remove the storefront token if we're using private app auth\n            delete headers['X-Shopify-Storefront-Access-Token'];\n        } else if (storePassword) {\n            console.log('Using password-protected store access');\n            // Base64 encode the credentials (HTTP Basic Authentication)\n            // For storefront password protection, no username is needed\n            const base64StoreCredentials = Buffer.from(\"\".concat(storePassword, \":\")).toString('base64');\n            headers['Authorization'] = \"Basic \".concat(base64StoreCredentials);\n        }\n        // Log the request information for debugging (safely)\n        console.log('Shopify API Request URL:', apiUrl);\n        console.log('Using access token:', storefrontAccessToken ? 'Token exists' : 'No token provided');\n        console.log('Using API key:', apiKey ? 'Yes' : 'No');\n        console.log('Password protected:', storePassword ? 'Yes' : 'No');\n        const result = await fetch(apiUrl, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({\n                query,\n                variables\n            })\n        });\n        const responseBody = await result.json();\n        // Log the response for debugging\n        console.log('Shopify API Response Status:', result.status);\n        if (result.status !== 200) {\n            console.log('Shopify API Response Errors:', responseBody.errors);\n        }\n        return {\n            status: result.status,\n            body: responseBody\n        };\n    } catch (error) {\n        console.error('Error fetching data from Shopify:', error);\n        return {\n            status: 500,\n            body: {\n                errors: [\n                    {\n                        message: 'Error fetching data from Shopify'\n                    }\n                ]\n            }\n        };\n    }\n};\nasync function getAllProducts() {\n    const query = \"\\n    query GetAllProducts {\\n      products(first: 100) {\\n        edges {\\n          node {\\n            id\\n            title\\n            description\\n            handle\\n            priceRange {\\n              minVariantPrice {\\n                amount\\n                currencyCode\\n              }\\n            }\\n            images(first: 1) {\\n              edges {\\n                node {\\n                  url\\n                  altText\\n                }\\n              }\\n            }\\n            variants(first: 100) {\\n              edges {\\n                node {\\n                  id\\n                  title\\n                  price {\\n                    amount\\n                    currencyCode\\n                  }\\n                  availableForSale\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  \";\n    const response = await shopifyFetch({\n        query\n    });\n    if (response.status !== 200 || !response.body.data) {\n        console.error('Error fetching products:', response.body.errors);\n        return [];\n    }\n    const products = response.body.data.products.edges.map((param)=>{\n        let { node } = param;\n        var _node_images_edges_, _node_images_edges_1;\n        const product = {\n            id: node.id,\n            title: node.title,\n            description: node.description,\n            handle: node.handle,\n            price: node.priceRange.minVariantPrice.amount,\n            currencyCode: node.priceRange.minVariantPrice.currencyCode,\n            image: ((_node_images_edges_ = node.images.edges[0]) === null || _node_images_edges_ === void 0 ? void 0 : _node_images_edges_.node.url) || '',\n            imageAlt: ((_node_images_edges_1 = node.images.edges[0]) === null || _node_images_edges_1 === void 0 ? void 0 : _node_images_edges_1.node.altText) || node.title,\n            variants: node.variants.edges.map((param)=>{\n                let { node: variant } = param;\n                return {\n                    id: variant.id,\n                    title: variant.title,\n                    price: variant.price.amount,\n                    currencyCode: variant.price.currencyCode,\n                    availableForSale: variant.availableForSale\n                };\n            })\n        };\n        return product;\n    });\n    return products;\n}\nasync function getProductByHandle(handle) {\n    var _product_images_edges_, _product_images_edges_1;\n    const query = \"\\n    query GetProductByHandle($handle: String!) {\\n      productByHandle(handle: $handle) {\\n        id\\n        title\\n        description\\n        handle\\n        descriptionHtml\\n        priceRange {\\n          minVariantPrice {\\n            amount\\n            currencyCode\\n          }\\n        }\\n        images(first: 10) {\\n          edges {\\n            node {\\n              url\\n              altText\\n              width\\n              height\\n            }\\n          }\\n        }\\n        variants(first: 100) {\\n          edges {\\n            node {\\n              id\\n              title\\n              price {\\n                amount\\n                currencyCode\\n              }\\n              availableForSale\\n            }\\n          }\\n        }\\n      }\\n    }\\n  \";\n    const variables = {\n        handle\n    };\n    const response = await shopifyFetch({\n        query,\n        variables\n    });\n    if (response.status !== 200 || !response.body.data.productByHandle) {\n        console.error('Error fetching product:', response.body.errors);\n        return null;\n    }\n    const product = response.body.data.productByHandle;\n    return {\n        id: product.id,\n        title: product.title,\n        description: product.description,\n        handle: product.handle,\n        descriptionHtml: product.descriptionHtml,\n        price: product.priceRange.minVariantPrice.amount,\n        currencyCode: product.priceRange.minVariantPrice.currencyCode,\n        images: product.images.edges.map((param)=>{\n            let { node } = param;\n            return {\n                url: node.url,\n                altText: node.altText || product.title,\n                width: node.width,\n                height: node.height\n            };\n        }),\n        image: ((_product_images_edges_ = product.images.edges[0]) === null || _product_images_edges_ === void 0 ? void 0 : _product_images_edges_.node.url) || '',\n        imageAlt: ((_product_images_edges_1 = product.images.edges[0]) === null || _product_images_edges_1 === void 0 ? void 0 : _product_images_edges_1.node.altText) || product.title,\n        variants: product.variants.edges.map((param)=>{\n            let { node: variant } = param;\n            return {\n                id: variant.id,\n                title: variant.title,\n                price: variant.price.amount,\n                currencyCode: variant.price.currencyCode,\n                availableForSale: variant.availableForSale\n            };\n        })\n    };\n}\nasync function createCheckout(cartItems) {\n    var _response_body_data_checkoutCreate_checkoutUserErrors, _response_body_data_checkoutCreate, _response_body_data;\n    const lineItems = cartItems.map((item)=>({\n            variantId: item.variantId,\n            quantity: item.quantity\n        }));\n    const query = \"\\n    mutation CheckoutCreate($input: CheckoutCreateInput!) {\\n      checkoutCreate(input: $input) {\\n        checkout {\\n          id\\n          webUrl\\n        }\\n        checkoutUserErrors {\\n          code\\n          field\\n          message\\n        }\\n      }\\n    }\\n  \";\n    const variables = {\n        input: {\n            lineItems\n        }\n    };\n    const response = await shopifyFetch({\n        query,\n        variables\n    });\n    if (response.status !== 200 || ((_response_body_data = response.body.data) === null || _response_body_data === void 0 ? void 0 : (_response_body_data_checkoutCreate = _response_body_data.checkoutCreate) === null || _response_body_data_checkoutCreate === void 0 ? void 0 : (_response_body_data_checkoutCreate_checkoutUserErrors = _response_body_data_checkoutCreate.checkoutUserErrors) === null || _response_body_data_checkoutCreate_checkoutUserErrors === void 0 ? void 0 : _response_body_data_checkoutCreate_checkoutUserErrors.length) > 0) {\n        var _response_body_data_checkoutCreate1, _response_body_data1;\n        console.error('Error creating checkout:', response.body.errors || ((_response_body_data1 = response.body.data) === null || _response_body_data1 === void 0 ? void 0 : (_response_body_data_checkoutCreate1 = _response_body_data1.checkoutCreate) === null || _response_body_data_checkoutCreate1 === void 0 ? void 0 : _response_body_data_checkoutCreate1.checkoutUserErrors));\n        return null;\n    }\n    return response.body.data.checkoutCreate.checkout.webUrl;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9saWIvc2hvcGlmeS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUVBLGdFQUFnRTtBQUNoRSxNQUFNQSxTQUFTLENBQUNDLCtCQUE0QyxJQUFJLENBQUMsRUFBR0csSUFBSTtBQUN4RSxNQUFNQyx3QkFBd0JKLDZDQUF1RCxJQUFJLENBQUU7QUFDM0YsTUFBTU0sZ0JBQWdCTixPQUFPQSxDQUFDQyxHQUFHLENBQUNNLHNCQUFzQixJQUFJO0FBQzVELE1BQU1DLFNBQVNSLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ1EsZUFBZSxJQUFJO0FBQzlDLE1BQU1DLFlBQVlWLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ1Usa0JBQWtCLElBQUk7QUFFcEQsZ0JBQWdCO0FBQ2hCQyxRQUFRQyxHQUFHLENBQUM7QUFDWkQsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQmQsVUFBVTtBQUM1Q2EsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQlQsd0JBQXdCLFFBQVE7QUFDdkVRLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0JMLFNBQVMsUUFBUTtBQUNuREksUUFBUUMsR0FBRyxDQUFDLHlCQUF5QkgsWUFBWSxRQUFRO0FBQ3pERSxRQUFRQyxHQUFHLENBQUMsNkJBQTZCUCxnQkFBZ0IsUUFBUTtBQUVqRSwrQkFBK0I7QUFDL0IsTUFBTVEsZUFBZTtRQUFPLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFzQztJQUNsRixJQUFJO1FBQ0YsaUVBQWlFO1FBQ2pFLE1BQU1DLFNBQVMsV0FBa0IsT0FBUGxCLFFBQU87UUFFakMscUNBQXFDO1FBQ3JDLHFFQUFxRTtRQUVyRSxzRUFBc0U7UUFDdEUsTUFBTW1CLFVBQWtDO1lBQ3RDLGdCQUFnQjtZQUNoQixxQ0FBcUNkO1FBQ3ZDO1FBRUEsaURBQWlEO1FBRWpELHlEQUF5RDtRQUN6RCwyQ0FBMkM7UUFFM0MsMENBQTBDO1FBQzFDLElBQUlJLFVBQVVFLFdBQVc7WUFDdkJFLFFBQVFDLEdBQUcsQ0FBQztZQUNaLHFFQUFxRTtZQUNyRSwwREFBMEQ7WUFDMUQsTUFBTU0sOEJBQThCQyxNQUFNQSxDQUFDQyxJQUFJLENBQUMsR0FBYVgsT0FBVkYsUUFBTyxLQUFhLE9BQVZFLFlBQWFZLFFBQVEsQ0FBQztZQUNuRkosT0FBTyxDQUFDLGdCQUFnQixHQUFHLFNBQXFDLE9BQTVCQztZQUVwQyw4REFBOEQ7WUFDOUQsT0FBT0QsT0FBTyxDQUFDLG9DQUFvQztRQUNyRCxPQUdLLElBQUlaLGVBQWU7WUFDdEJNLFFBQVFDLEdBQUcsQ0FBQztZQUNaLDREQUE0RDtZQUM1RCw0REFBNEQ7WUFDNUQsTUFBTVUseUJBQXlCSCxNQUFNQSxDQUFDQyxJQUFJLENBQUMsR0FBaUIsT0FBZGYsZUFBYyxNQUFJZ0IsUUFBUSxDQUFDO1lBQ3pFSixPQUFPLENBQUMsZ0JBQWdCLEdBQUcsU0FBZ0MsT0FBdkJLO1FBQ3RDO1FBRUEscURBQXFEO1FBQ3JEWCxRQUFRQyxHQUFHLENBQUMsNEJBQTRCSTtRQUN4Q0wsUUFBUUMsR0FBRyxDQUFDLHVCQUF1QlQsd0JBQXdCLGlCQUFpQjtRQUM1RVEsUUFBUUMsR0FBRyxDQUFDLGtCQUFrQkwsU0FBUyxRQUFRO1FBQy9DSSxRQUFRQyxHQUFHLENBQUMsdUJBQXVCUCxnQkFBZ0IsUUFBUTtRQUUzRCxNQUFNa0IsU0FBUyxNQUFNQyxNQUFNUixRQUFRO1lBQ2pDUyxRQUFRO1lBQ1JSO1lBQ0FTLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztnQkFBRWQ7Z0JBQU9DO1lBQVU7UUFDMUM7UUFFQSxNQUFNYyxlQUFlLE1BQU1OLE9BQU9PLElBQUk7UUFFdEMsaUNBQWlDO1FBQ2pDbkIsUUFBUUMsR0FBRyxDQUFDLGdDQUFnQ1csT0FBT1EsTUFBTTtRQUN6RCxJQUFJUixPQUFPUSxNQUFNLEtBQUssS0FBSztZQUN6QnBCLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0NpQixhQUFhRyxNQUFNO1FBQ2pFO1FBRUEsT0FBTztZQUNMRCxRQUFRUixPQUFPUSxNQUFNO1lBQ3JCTCxNQUFNRztRQUNSO0lBQ0YsRUFBRSxPQUFPSSxPQUFPO1FBQ2R0QixRQUFRc0IsS0FBSyxDQUFDLHFDQUFxQ0E7UUFDbkQsT0FBTztZQUNMRixRQUFRO1lBQ1JMLE1BQU07Z0JBQUVNLFFBQVE7b0JBQUM7d0JBQUVFLFNBQVM7b0JBQW1DO2lCQUFFO1lBQUM7UUFDcEU7SUFDRjtBQUNGO0FBRU8sZUFBZUM7SUFDcEIsTUFBTXJCLFFBQVM7SUEwQ2YsTUFBTXNCLFdBQVcsTUFBTXZCLGFBQWE7UUFBRUM7SUFBTTtJQUU1QyxJQUFJc0IsU0FBU0wsTUFBTSxLQUFLLE9BQU8sQ0FBQ0ssU0FBU1YsSUFBSSxDQUFDVyxJQUFJLEVBQUU7UUFDbEQxQixRQUFRc0IsS0FBSyxDQUFDLDRCQUE0QkcsU0FBU1YsSUFBSSxDQUFDTSxNQUFNO1FBQzlELE9BQU8sRUFBRTtJQUNYO0lBRUEsTUFBTU0sV0FBV0YsU0FBU1YsSUFBSSxDQUFDVyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHLENBQUM7WUFBQyxFQUFFQyxJQUFJLEVBQU87WUFRMURBLHFCQUNHQTtRQVJaLE1BQU1DLFVBQW1CO1lBQ3ZCQyxJQUFJRixLQUFLRSxFQUFFO1lBQ1hDLE9BQU9ILEtBQUtHLEtBQUs7WUFDakJDLGFBQWFKLEtBQUtJLFdBQVc7WUFDN0JDLFFBQVFMLEtBQUtLLE1BQU07WUFDbkJDLE9BQU9OLEtBQUtPLFVBQVUsQ0FBQ0MsZUFBZSxDQUFDQyxNQUFNO1lBQzdDQyxjQUFjVixLQUFLTyxVQUFVLENBQUNDLGVBQWUsQ0FBQ0UsWUFBWTtZQUMxREMsT0FBT1gsRUFBQUEsc0JBQUFBLEtBQUtZLE1BQU0sQ0FBQ2QsS0FBSyxDQUFDLEVBQUUsY0FBcEJFLDBDQUFBQSxvQkFBc0JBLElBQUksQ0FBQ2EsR0FBRyxLQUFJO1lBQ3pDQyxVQUFVZCxFQUFBQSx1QkFBQUEsS0FBS1ksTUFBTSxDQUFDZCxLQUFLLENBQUMsRUFBRSxjQUFwQkUsMkNBQUFBLHFCQUFzQkEsSUFBSSxDQUFDZSxPQUFPLEtBQUlmLEtBQUtHLEtBQUs7WUFDMURhLFVBQVVoQixLQUFLZ0IsUUFBUSxDQUFDbEIsS0FBSyxDQUFDQyxHQUFHLENBQUM7b0JBQUMsRUFBRUMsTUFBTWlCLE9BQU8sRUFBTzt1QkFBc0I7b0JBQzdFZixJQUFJZSxRQUFRZixFQUFFO29CQUNkQyxPQUFPYyxRQUFRZCxLQUFLO29CQUNwQkcsT0FBT1csUUFBUVgsS0FBSyxDQUFDRyxNQUFNO29CQUMzQkMsY0FBY08sUUFBUVgsS0FBSyxDQUFDSSxZQUFZO29CQUN4Q1Esa0JBQWtCRCxRQUFRQyxnQkFBZ0I7Z0JBQzVDOztRQUNGO1FBQ0EsT0FBT2pCO0lBQ1Q7SUFFQSxPQUFPSjtBQUNUO0FBRU8sZUFBZXNCLG1CQUFtQmQsTUFBYztRQWtFNUNKLHdCQUNHQTtJQWxFWixNQUFNNUIsUUFBUztJQXlDZixNQUFNQyxZQUFZO1FBQUUrQjtJQUFPO0lBQzNCLE1BQU1WLFdBQVcsTUFBTXZCLGFBQWE7UUFBRUM7UUFBT0M7SUFBVTtJQUV2RCxJQUFJcUIsU0FBU0wsTUFBTSxLQUFLLE9BQU8sQ0FBQ0ssU0FBU1YsSUFBSSxDQUFDVyxJQUFJLENBQUN3QixlQUFlLEVBQUU7UUFDbEVsRCxRQUFRc0IsS0FBSyxDQUFDLDJCQUEyQkcsU0FBU1YsSUFBSSxDQUFDTSxNQUFNO1FBQzdELE9BQU87SUFDVDtJQUVBLE1BQU1VLFVBQVVOLFNBQVNWLElBQUksQ0FBQ1csSUFBSSxDQUFDd0IsZUFBZTtJQUVsRCxPQUFPO1FBQ0xsQixJQUFJRCxRQUFRQyxFQUFFO1FBQ2RDLE9BQU9GLFFBQVFFLEtBQUs7UUFDcEJDLGFBQWFILFFBQVFHLFdBQVc7UUFDaENDLFFBQVFKLFFBQVFJLE1BQU07UUFDdEJnQixpQkFBaUJwQixRQUFRb0IsZUFBZTtRQUN4Q2YsT0FBT0wsUUFBUU0sVUFBVSxDQUFDQyxlQUFlLENBQUNDLE1BQU07UUFDaERDLGNBQWNULFFBQVFNLFVBQVUsQ0FBQ0MsZUFBZSxDQUFDRSxZQUFZO1FBQzdERSxRQUFRWCxRQUFRVyxNQUFNLENBQUNkLEtBQUssQ0FBQ0MsR0FBRyxDQUFDO2dCQUFDLEVBQUVDLElBQUksRUFBTzttQkFBTTtnQkFDbkRhLEtBQUtiLEtBQUthLEdBQUc7Z0JBQ2JFLFNBQVNmLEtBQUtlLE9BQU8sSUFBSWQsUUFBUUUsS0FBSztnQkFDdENtQixPQUFPdEIsS0FBS3NCLEtBQUs7Z0JBQ2pCQyxRQUFRdkIsS0FBS3VCLE1BQU07WUFDckI7O1FBQ0FaLE9BQU9WLEVBQUFBLHlCQUFBQSxRQUFRVyxNQUFNLENBQUNkLEtBQUssQ0FBQyxFQUFFLGNBQXZCRyw2Q0FBQUEsdUJBQXlCRCxJQUFJLENBQUNhLEdBQUcsS0FBSTtRQUM1Q0MsVUFBVWIsRUFBQUEsMEJBQUFBLFFBQVFXLE1BQU0sQ0FBQ2QsS0FBSyxDQUFDLEVBQUUsY0FBdkJHLDhDQUFBQSx3QkFBeUJELElBQUksQ0FBQ2UsT0FBTyxLQUFJZCxRQUFRRSxLQUFLO1FBQ2hFYSxVQUFVZixRQUFRZSxRQUFRLENBQUNsQixLQUFLLENBQUNDLEdBQUcsQ0FBQztnQkFBQyxFQUFFQyxNQUFNaUIsT0FBTyxFQUFPO21CQUFzQjtnQkFDaEZmLElBQUllLFFBQVFmLEVBQUU7Z0JBQ2RDLE9BQU9jLFFBQVFkLEtBQUs7Z0JBQ3BCRyxPQUFPVyxRQUFRWCxLQUFLLENBQUNHLE1BQU07Z0JBQzNCQyxjQUFjTyxRQUFRWCxLQUFLLENBQUNJLFlBQVk7Z0JBQ3hDUSxrQkFBa0JELFFBQVFDLGdCQUFnQjtZQUM1Qzs7SUFDRjtBQUNGO0FBRU8sZUFBZU0sZUFBZUMsU0FBcUI7UUE4QnpCOUIsdURBQUFBLG9DQUFBQTtJQTdCL0IsTUFBTStCLFlBQVlELFVBQVUxQixHQUFHLENBQUM0QixDQUFBQSxPQUFTO1lBQ3ZDQyxXQUFXRCxLQUFLQyxTQUFTO1lBQ3pCQyxVQUFVRixLQUFLRSxRQUFRO1FBQ3pCO0lBRUEsTUFBTXhELFFBQVM7SUFnQmYsTUFBTUMsWUFBWTtRQUNoQndELE9BQU87WUFDTEo7UUFDRjtJQUNGO0lBRUEsTUFBTS9CLFdBQVcsTUFBTXZCLGFBQWE7UUFBRUM7UUFBT0M7SUFBVTtJQUV2RCxJQUFJcUIsU0FBU0wsTUFBTSxLQUFLLE9BQU9LLEVBQUFBLHNCQUFBQSxTQUFTVixJQUFJLENBQUNXLElBQUksY0FBbEJELDJDQUFBQSxxQ0FBQUEsb0JBQW9Cb0MsY0FBYyxjQUFsQ3BDLDBEQUFBQSx3REFBQUEsbUNBQW9DcUMsa0JBQWtCLGNBQXREckMsNEVBQUFBLHNEQUF3RHNDLE1BQU0sSUFBRyxHQUFHO1lBQy9CdEMscUNBQUFBO1FBQWxFekIsUUFBUXNCLEtBQUssQ0FBQyw0QkFBNEJHLFNBQVNWLElBQUksQ0FBQ00sTUFBTSxNQUFJSSx1QkFBQUEsU0FBU1YsSUFBSSxDQUFDVyxJQUFJLGNBQWxCRCw0Q0FBQUEsc0NBQUFBLHFCQUFvQm9DLGNBQWMsY0FBbENwQywwREFBQUEsb0NBQW9DcUMsa0JBQWtCO1FBQ3hILE9BQU87SUFDVDtJQUVBLE9BQU9yQyxTQUFTVixJQUFJLENBQUNXLElBQUksQ0FBQ21DLGNBQWMsQ0FBQ0csUUFBUSxDQUFDQyxNQUFNO0FBQzFEIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL3NyYy9saWIvc2hvcGlmeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcm9kdWN0LCBQcm9kdWN0VmFyaWFudCwgQ29sbGVjdGlvbiwgQ2FydEl0ZW0gfSBmcm9tICdAL3R5cGVzJztcblxuLy8gVHJpbSBhbnkgc3BhY2VzIGZyb20gdGhlIGRvbWFpbiB0byBwcmV2ZW50IFVSTCBwYXJzaW5nIGVycm9yc1xuY29uc3QgZG9tYWluID0gKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NIT1BJRllfU1RPUkVfRE9NQUlOIHx8ICcnKS50cmltKCk7XG5jb25zdCBzdG9yZWZyb250QWNjZXNzVG9rZW4gPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TSE9QSUZZX1NUT1JFRlJPTlRfQUNDRVNTX1RPS0VOIHx8ICcnO1xuY29uc3Qgc3RvcmVQYXNzd29yZCA9IHByb2Nlc3MuZW52LlNIT1BJRllfU1RPUkVfUEFTU1dPUkQgfHwgJyc7XG5jb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5TSE9QSUZZX0FQSV9LRVkgfHwgJyc7XG5jb25zdCBhcGlTZWNyZXQgPSBwcm9jZXNzLmVudi5TSE9QSUZZX0FQSV9TRUNSRVQgfHwgJyc7XG5cbi8vIEZvciBkZWJ1Z2dpbmdcbmNvbnNvbGUubG9nKCdFbnZpcm9ubWVudCBjaGVjazonKTtcbmNvbnNvbGUubG9nKCdEb21haW4gY29uZmlndXJlZDonLCBkb21haW4gfHwgJ05vdCBzZXQnKTtcbmNvbnNvbGUubG9nKCdBY2Nlc3MgdG9rZW4gYXZhaWxhYmxlOicsIHN0b3JlZnJvbnRBY2Nlc3NUb2tlbiA/ICdZZXMnIDogJ05vJyk7XG5jb25zb2xlLmxvZygnQVBJIGtleSBhdmFpbGFibGU6JywgYXBpS2V5ID8gJ1llcycgOiAnTm8nKTtcbmNvbnNvbGUubG9nKCdBUEkgc2VjcmV0IGF2YWlsYWJsZTonLCBhcGlTZWNyZXQgPyAnWWVzJyA6ICdObycpO1xuY29uc29sZS5sb2coJ1N0b3JlIHBhc3N3b3JkIGF2YWlsYWJsZTonLCBzdG9yZVBhc3N3b3JkID8gJ1llcycgOiAnTm8nKTtcblxuLy8gVHJ5IG11bHRpcGxlIGF1dGggc3RyYXRlZ2llc1xuY29uc3Qgc2hvcGlmeUZldGNoID0gYXN5bmMgKHsgcXVlcnksIHZhcmlhYmxlcyB9OiB7IHF1ZXJ5OiBzdHJpbmc7IHZhcmlhYmxlcz86IGFueSB9KSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gU2V0IHVwIHRoZSBBUEkgVVJMIC0gdHJ5IHVzaW5nIHRoZSBTdG9yZWZyb250IEFQSSBzcGVjaWZpY2FsbHlcbiAgICBjb25zdCBhcGlVcmwgPSBgaHR0cHM6Ly8ke2RvbWFpbn0vYXBpLzIwMjQtMDEvZ3JhcGhxbC5qc29uYDtcbiAgICBcbiAgICAvLyBGb3IgYWRtaW4gQVBJIGFjY2VzcyB3ZSB3b3VsZCB1c2U6XG4gICAgLy8gY29uc3QgYXBpVXJsID0gYGh0dHBzOi8vJHtkb21haW59L2FkbWluL2FwaS8yMDI0LTAxL2dyYXBocWwuanNvbmA7XG4gICAgXG4gICAgLy8gUHJlcGFyZSBoZWFkZXJzIHdpdGggYXV0aGVudGljYXRpb24gLSB3ZSdsbCB0cnkgbXVsdGlwbGUgYXBwcm9hY2hlc1xuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ1gtU2hvcGlmeS1TdG9yZWZyb250LUFjY2Vzcy1Ub2tlbic6IHN0b3JlZnJvbnRBY2Nlc3NUb2tlbixcbiAgICB9O1xuICAgIFxuICAgIC8vIFRyeSBhIGNvbWJpbmF0aW9uIG9mIGF1dGhlbnRpY2F0aW9uIGFwcHJvYWNoZXNcbiAgICBcbiAgICAvLyBPcHRpb24gMTogVXNlIHRoZSBTdG9yZWZyb250IEFQSSB0b2tlbiBmb3IgcHVibGljIGFwcHNcbiAgICAvLyBUaGlzIGlzIGFscmVhZHkgc2V0IGluIHRoZSBoZWFkZXJzIGFib3ZlXG4gICAgXG4gICAgLy8gT3B0aW9uIDI6IEZvciBwcml2YXRlIGFwcHMgb3IgYWRtaW4gQVBJXG4gICAgaWYgKGFwaUtleSAmJiBhcGlTZWNyZXQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBwcml2YXRlIGFwcCBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgLy8gRm9yIHByaXZhdGUgYXBwIGF1dGhlbnRpY2F0aW9uLCB3ZSB1c2UgdGhlIEFQSSBrZXkgYXMgdGhlIHVzZXJuYW1lXG4gICAgICAvLyBhbmQgdGhlIHBhc3N3b3JkIGFzIHRoZSBBUEkgc2VjcmV0L3ByaXZhdGUgYXBwIHBhc3N3b3JkXG4gICAgICBjb25zdCBiYXNlNjRQcml2YXRlQXBwQ3JlZGVudGlhbHMgPSBCdWZmZXIuZnJvbShgJHthcGlLZXl9OiR7YXBpU2VjcmV0fWApLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke2Jhc2U2NFByaXZhdGVBcHBDcmVkZW50aWFsc31gO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgdGhlIHN0b3JlZnJvbnQgdG9rZW4gaWYgd2UncmUgdXNpbmcgcHJpdmF0ZSBhcHAgYXV0aFxuICAgICAgZGVsZXRlIGhlYWRlcnNbJ1gtU2hvcGlmeS1TdG9yZWZyb250LUFjY2Vzcy1Ub2tlbiddO1xuICAgIH1cbiAgICBcbiAgICAvLyBPcHRpb24gMzogRm9yIHBhc3N3b3JkLXByb3RlY3RlZCBzdG9yZWZyb250c1xuICAgIGVsc2UgaWYgKHN0b3JlUGFzc3dvcmQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBwYXNzd29yZC1wcm90ZWN0ZWQgc3RvcmUgYWNjZXNzJyk7XG4gICAgICAvLyBCYXNlNjQgZW5jb2RlIHRoZSBjcmVkZW50aWFscyAoSFRUUCBCYXNpYyBBdXRoZW50aWNhdGlvbilcbiAgICAgIC8vIEZvciBzdG9yZWZyb250IHBhc3N3b3JkIHByb3RlY3Rpb24sIG5vIHVzZXJuYW1lIGlzIG5lZWRlZFxuICAgICAgY29uc3QgYmFzZTY0U3RvcmVDcmVkZW50aWFscyA9IEJ1ZmZlci5mcm9tKGAke3N0b3JlUGFzc3dvcmR9OmApLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke2Jhc2U2NFN0b3JlQ3JlZGVudGlhbHN9YDtcbiAgICB9XG4gICAgXG4gICAgLy8gTG9nIHRoZSByZXF1ZXN0IGluZm9ybWF0aW9uIGZvciBkZWJ1Z2dpbmcgKHNhZmVseSlcbiAgICBjb25zb2xlLmxvZygnU2hvcGlmeSBBUEkgUmVxdWVzdCBVUkw6JywgYXBpVXJsKTtcbiAgICBjb25zb2xlLmxvZygnVXNpbmcgYWNjZXNzIHRva2VuOicsIHN0b3JlZnJvbnRBY2Nlc3NUb2tlbiA/ICdUb2tlbiBleGlzdHMnIDogJ05vIHRva2VuIHByb3ZpZGVkJyk7XG4gICAgY29uc29sZS5sb2coJ1VzaW5nIEFQSSBrZXk6JywgYXBpS2V5ID8gJ1llcycgOiAnTm8nKTtcbiAgICBjb25zb2xlLmxvZygnUGFzc3dvcmQgcHJvdGVjdGVkOicsIHN0b3JlUGFzc3dvcmQgPyAnWWVzJyA6ICdObycpO1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoKGFwaVVybCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBxdWVyeSwgdmFyaWFibGVzIH0pLFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgXG4gICAgLy8gTG9nIHRoZSByZXNwb25zZSBmb3IgZGVidWdnaW5nXG4gICAgY29uc29sZS5sb2coJ1Nob3BpZnkgQVBJIFJlc3BvbnNlIFN0YXR1czonLCByZXN1bHQuc3RhdHVzKTtcbiAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnU2hvcGlmeSBBUEkgUmVzcG9uc2UgRXJyb3JzOicsIHJlc3BvbnNlQm9keS5lcnJvcnMpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiByZXN1bHQuc3RhdHVzLFxuICAgICAgYm9keTogcmVzcG9uc2VCb2R5LFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZGF0YSBmcm9tIFNob3BpZnk6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIGJvZHk6IHsgZXJyb3JzOiBbeyBtZXNzYWdlOiAnRXJyb3IgZmV0Y2hpbmcgZGF0YSBmcm9tIFNob3BpZnknIH1dIH0sXG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFByb2R1Y3RzKCk6IFByb21pc2U8UHJvZHVjdFtdPiB7XG4gIGNvbnN0IHF1ZXJ5ID0gYFxuICAgIHF1ZXJ5IEdldEFsbFByb2R1Y3RzIHtcbiAgICAgIHByb2R1Y3RzKGZpcnN0OiAxMDApIHtcbiAgICAgICAgZWRnZXMge1xuICAgICAgICAgIG5vZGUge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgICBkZXNjcmlwdGlvblxuICAgICAgICAgICAgaGFuZGxlXG4gICAgICAgICAgICBwcmljZVJhbmdlIHtcbiAgICAgICAgICAgICAgbWluVmFyaWFudFByaWNlIHtcbiAgICAgICAgICAgICAgICBhbW91bnRcbiAgICAgICAgICAgICAgICBjdXJyZW5jeUNvZGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2VzKGZpcnN0OiAxKSB7XG4gICAgICAgICAgICAgIGVkZ2VzIHtcbiAgICAgICAgICAgICAgICBub2RlIHtcbiAgICAgICAgICAgICAgICAgIHVybFxuICAgICAgICAgICAgICAgICAgYWx0VGV4dFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyaWFudHMoZmlyc3Q6IDEwMCkge1xuICAgICAgICAgICAgICBlZGdlcyB7XG4gICAgICAgICAgICAgICAgbm9kZSB7XG4gICAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICAgICAgdGl0bGVcbiAgICAgICAgICAgICAgICAgIHByaWNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5Q29kZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlRm9yU2FsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgYDtcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNob3BpZnlGZXRjaCh7IHF1ZXJ5IH0pO1xuICBcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwIHx8ICFyZXNwb25zZS5ib2R5LmRhdGEpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9kdWN0czonLCByZXNwb25zZS5ib2R5LmVycm9ycyk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgcHJvZHVjdHMgPSByZXNwb25zZS5ib2R5LmRhdGEucHJvZHVjdHMuZWRnZXMubWFwKCh7IG5vZGUgfTogYW55KSA9PiB7XG4gICAgY29uc3QgcHJvZHVjdDogUHJvZHVjdCA9IHtcbiAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgdGl0bGU6IG5vZGUudGl0bGUsXG4gICAgICBkZXNjcmlwdGlvbjogbm9kZS5kZXNjcmlwdGlvbixcbiAgICAgIGhhbmRsZTogbm9kZS5oYW5kbGUsXG4gICAgICBwcmljZTogbm9kZS5wcmljZVJhbmdlLm1pblZhcmlhbnRQcmljZS5hbW91bnQsXG4gICAgICBjdXJyZW5jeUNvZGU6IG5vZGUucHJpY2VSYW5nZS5taW5WYXJpYW50UHJpY2UuY3VycmVuY3lDb2RlLFxuICAgICAgaW1hZ2U6IG5vZGUuaW1hZ2VzLmVkZ2VzWzBdPy5ub2RlLnVybCB8fCAnJyxcbiAgICAgIGltYWdlQWx0OiBub2RlLmltYWdlcy5lZGdlc1swXT8ubm9kZS5hbHRUZXh0IHx8IG5vZGUudGl0bGUsXG4gICAgICB2YXJpYW50czogbm9kZS52YXJpYW50cy5lZGdlcy5tYXAoKHsgbm9kZTogdmFyaWFudCB9OiBhbnkpOiBQcm9kdWN0VmFyaWFudCA9PiAoe1xuICAgICAgICBpZDogdmFyaWFudC5pZCxcbiAgICAgICAgdGl0bGU6IHZhcmlhbnQudGl0bGUsXG4gICAgICAgIHByaWNlOiB2YXJpYW50LnByaWNlLmFtb3VudCxcbiAgICAgICAgY3VycmVuY3lDb2RlOiB2YXJpYW50LnByaWNlLmN1cnJlbmN5Q29kZSxcbiAgICAgICAgYXZhaWxhYmxlRm9yU2FsZTogdmFyaWFudC5hdmFpbGFibGVGb3JTYWxlLFxuICAgICAgfSkpLFxuICAgIH07XG4gICAgcmV0dXJuIHByb2R1Y3Q7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9kdWN0cztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByb2R1Y3RCeUhhbmRsZShoYW5kbGU6IHN0cmluZyk6IFByb21pc2U8UHJvZHVjdCB8IG51bGw+IHtcbiAgY29uc3QgcXVlcnkgPSBgXG4gICAgcXVlcnkgR2V0UHJvZHVjdEJ5SGFuZGxlKCRoYW5kbGU6IFN0cmluZyEpIHtcbiAgICAgIHByb2R1Y3RCeUhhbmRsZShoYW5kbGU6ICRoYW5kbGUpIHtcbiAgICAgICAgaWRcbiAgICAgICAgdGl0bGVcbiAgICAgICAgZGVzY3JpcHRpb25cbiAgICAgICAgaGFuZGxlXG4gICAgICAgIGRlc2NyaXB0aW9uSHRtbFxuICAgICAgICBwcmljZVJhbmdlIHtcbiAgICAgICAgICBtaW5WYXJpYW50UHJpY2Uge1xuICAgICAgICAgICAgYW1vdW50XG4gICAgICAgICAgICBjdXJyZW5jeUNvZGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2VzKGZpcnN0OiAxMCkge1xuICAgICAgICAgIGVkZ2VzIHtcbiAgICAgICAgICAgIG5vZGUge1xuICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgYWx0VGV4dFxuICAgICAgICAgICAgICB3aWR0aFxuICAgICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyaWFudHMoZmlyc3Q6IDEwMCkge1xuICAgICAgICAgIGVkZ2VzIHtcbiAgICAgICAgICAgIG5vZGUge1xuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgICBwcmljZSB7XG4gICAgICAgICAgICAgICAgYW1vdW50XG4gICAgICAgICAgICAgICAgY3VycmVuY3lDb2RlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXZhaWxhYmxlRm9yU2FsZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgYDtcblxuICBjb25zdCB2YXJpYWJsZXMgPSB7IGhhbmRsZSB9O1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNob3BpZnlGZXRjaCh7IHF1ZXJ5LCB2YXJpYWJsZXMgfSk7XG5cbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwIHx8ICFyZXNwb25zZS5ib2R5LmRhdGEucHJvZHVjdEJ5SGFuZGxlKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvZHVjdDonLCByZXNwb25zZS5ib2R5LmVycm9ycyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBwcm9kdWN0ID0gcmVzcG9uc2UuYm9keS5kYXRhLnByb2R1Y3RCeUhhbmRsZTtcbiAgXG4gIHJldHVybiB7XG4gICAgaWQ6IHByb2R1Y3QuaWQsXG4gICAgdGl0bGU6IHByb2R1Y3QudGl0bGUsXG4gICAgZGVzY3JpcHRpb246IHByb2R1Y3QuZGVzY3JpcHRpb24sXG4gICAgaGFuZGxlOiBwcm9kdWN0LmhhbmRsZSxcbiAgICBkZXNjcmlwdGlvbkh0bWw6IHByb2R1Y3QuZGVzY3JpcHRpb25IdG1sLFxuICAgIHByaWNlOiBwcm9kdWN0LnByaWNlUmFuZ2UubWluVmFyaWFudFByaWNlLmFtb3VudCxcbiAgICBjdXJyZW5jeUNvZGU6IHByb2R1Y3QucHJpY2VSYW5nZS5taW5WYXJpYW50UHJpY2UuY3VycmVuY3lDb2RlLFxuICAgIGltYWdlczogcHJvZHVjdC5pbWFnZXMuZWRnZXMubWFwKCh7IG5vZGUgfTogYW55KSA9PiAoe1xuICAgICAgdXJsOiBub2RlLnVybCxcbiAgICAgIGFsdFRleHQ6IG5vZGUuYWx0VGV4dCB8fCBwcm9kdWN0LnRpdGxlLFxuICAgICAgd2lkdGg6IG5vZGUud2lkdGgsXG4gICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0LFxuICAgIH0pKSxcbiAgICBpbWFnZTogcHJvZHVjdC5pbWFnZXMuZWRnZXNbMF0/Lm5vZGUudXJsIHx8ICcnLFxuICAgIGltYWdlQWx0OiBwcm9kdWN0LmltYWdlcy5lZGdlc1swXT8ubm9kZS5hbHRUZXh0IHx8IHByb2R1Y3QudGl0bGUsXG4gICAgdmFyaWFudHM6IHByb2R1Y3QudmFyaWFudHMuZWRnZXMubWFwKCh7IG5vZGU6IHZhcmlhbnQgfTogYW55KTogUHJvZHVjdFZhcmlhbnQgPT4gKHtcbiAgICAgIGlkOiB2YXJpYW50LmlkLFxuICAgICAgdGl0bGU6IHZhcmlhbnQudGl0bGUsXG4gICAgICBwcmljZTogdmFyaWFudC5wcmljZS5hbW91bnQsXG4gICAgICBjdXJyZW5jeUNvZGU6IHZhcmlhbnQucHJpY2UuY3VycmVuY3lDb2RlLFxuICAgICAgYXZhaWxhYmxlRm9yU2FsZTogdmFyaWFudC5hdmFpbGFibGVGb3JTYWxlLFxuICAgIH0pKSxcbiAgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNoZWNrb3V0KGNhcnRJdGVtczogQ2FydEl0ZW1bXSk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICBjb25zdCBsaW5lSXRlbXMgPSBjYXJ0SXRlbXMubWFwKGl0ZW0gPT4gKHtcbiAgICB2YXJpYW50SWQ6IGl0ZW0udmFyaWFudElkLFxuICAgIHF1YW50aXR5OiBpdGVtLnF1YW50aXR5LFxuICB9KSk7XG5cbiAgY29uc3QgcXVlcnkgPSBgXG4gICAgbXV0YXRpb24gQ2hlY2tvdXRDcmVhdGUoJGlucHV0OiBDaGVja291dENyZWF0ZUlucHV0ISkge1xuICAgICAgY2hlY2tvdXRDcmVhdGUoaW5wdXQ6ICRpbnB1dCkge1xuICAgICAgICBjaGVja291dCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgICB3ZWJVcmxcbiAgICAgICAgfVxuICAgICAgICBjaGVja291dFVzZXJFcnJvcnMge1xuICAgICAgICAgIGNvZGVcbiAgICAgICAgICBmaWVsZFxuICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgYDtcblxuICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgaW5wdXQ6IHtcbiAgICAgIGxpbmVJdGVtcyxcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2hvcGlmeUZldGNoKHsgcXVlcnksIHZhcmlhYmxlcyB9KTtcblxuICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDAgfHwgcmVzcG9uc2UuYm9keS5kYXRhPy5jaGVja291dENyZWF0ZT8uY2hlY2tvdXRVc2VyRXJyb3JzPy5sZW5ndGggPiAwKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgY2hlY2tvdXQ6JywgcmVzcG9uc2UuYm9keS5lcnJvcnMgfHwgcmVzcG9uc2UuYm9keS5kYXRhPy5jaGVja291dENyZWF0ZT8uY2hlY2tvdXRVc2VyRXJyb3JzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5ib2R5LmRhdGEuY2hlY2tvdXRDcmVhdGUuY2hlY2tvdXQud2ViVXJsO1xufVxuIl0sIm5hbWVzIjpbImRvbWFpbiIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TSE9QSUZZX1NUT1JFX0RPTUFJTiIsInRyaW0iLCJzdG9yZWZyb250QWNjZXNzVG9rZW4iLCJORVhUX1BVQkxJQ19TSE9QSUZZX1NUT1JFRlJPTlRfQUNDRVNTX1RPS0VOIiwic3RvcmVQYXNzd29yZCIsIlNIT1BJRllfU1RPUkVfUEFTU1dPUkQiLCJhcGlLZXkiLCJTSE9QSUZZX0FQSV9LRVkiLCJhcGlTZWNyZXQiLCJTSE9QSUZZX0FQSV9TRUNSRVQiLCJjb25zb2xlIiwibG9nIiwic2hvcGlmeUZldGNoIiwicXVlcnkiLCJ2YXJpYWJsZXMiLCJhcGlVcmwiLCJoZWFkZXJzIiwiYmFzZTY0UHJpdmF0ZUFwcENyZWRlbnRpYWxzIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwiYmFzZTY0U3RvcmVDcmVkZW50aWFscyIsInJlc3VsdCIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXNwb25zZUJvZHkiLCJqc29uIiwic3RhdHVzIiwiZXJyb3JzIiwiZXJyb3IiLCJtZXNzYWdlIiwiZ2V0QWxsUHJvZHVjdHMiLCJyZXNwb25zZSIsImRhdGEiLCJwcm9kdWN0cyIsImVkZ2VzIiwibWFwIiwibm9kZSIsInByb2R1Y3QiLCJpZCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJoYW5kbGUiLCJwcmljZSIsInByaWNlUmFuZ2UiLCJtaW5WYXJpYW50UHJpY2UiLCJhbW91bnQiLCJjdXJyZW5jeUNvZGUiLCJpbWFnZSIsImltYWdlcyIsInVybCIsImltYWdlQWx0IiwiYWx0VGV4dCIsInZhcmlhbnRzIiwidmFyaWFudCIsImF2YWlsYWJsZUZvclNhbGUiLCJnZXRQcm9kdWN0QnlIYW5kbGUiLCJwcm9kdWN0QnlIYW5kbGUiLCJkZXNjcmlwdGlvbkh0bWwiLCJ3aWR0aCIsImhlaWdodCIsImNyZWF0ZUNoZWNrb3V0IiwiY2FydEl0ZW1zIiwibGluZUl0ZW1zIiwiaXRlbSIsInZhcmlhbnRJZCIsInF1YW50aXR5IiwiaW5wdXQiLCJjaGVja291dENyZWF0ZSIsImNoZWNrb3V0VXNlckVycm9ycyIsImxlbmd0aCIsImNoZWNrb3V0Iiwid2ViVXJsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/lib/shopify.ts\n"));

/***/ })

});